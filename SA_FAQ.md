Системный аналитик
=
[Общие 120 вопросов](https://habr.com/ru/articles/591057/)

---

<h1 id="rest_soap">REST and SOAP</h1>  


[SOAP/REST](https://vc.ru/dev/563668-vse-chto-nuzhno-znat-o-rest-i-soap-gayd-dlya-testirovshchika)
&nbsp;
[SOAP/REST](https://aws.amazon.com/ru/compare/the-difference-between-soap-rest/)
&nbsp;
[API](https://aws.amazon.com/ru/what-is/api/)
&nbsp;
[XML](https://aws.amazon.com/ru/what-is/xml/)
&nbsp;
[JSON](https://habr.com/ru/articles/554274/)
&nbsp;

SOAP – это протокол, а REST – архитектурный стиль распределенных систем. Это создает значительные различия в функционировании SOAP и REST API.
<h2 id="rest_soap-API>API</h2>
Application Programming Interface - интерфейс прикладного программирования. Интерфейс можно рассматривать как сервисный контракт 
между двумя приложениями. Этот контракт определяет, как они взаимодействуют друг с другом, используя запросы и 
ответы. Перечень правил обращения к ресурсам сервера или между двумя приложениями. Регламентирует состав, реализацию точек контакта систем.
<h2 id="rest_soap-SOAP>SOAP</h2>
SOAP – Simple Object Access Protocol, т. е. простой протокол доступа к объектам. Клиент и сервер обмениваются сообщениями посредством XML. Это менее гибкий API, который был более популярен в прошлом.
SOAP – это протокол, определяющий строгие правила коммуникации. С ним связано несколько стандартов, регулирующих каждый аспект обмена данными.
При отправке запроса в SOAP API необходимо обернуть HTTP-запрос в конверт SOAP. Это структура данных, которая изменяет базовый HTTP-контент в соответствии с требованиями к запросам SOAP.
<h2 id="rest_soap-REST>REST</h2>
Клиент отправляет запросы на сервер в виде данных. Сервер использует этот клиентский ввод для запуска внутренних функций и возвращает выходные данные обратно клиенту.
REST – это Representational State Transfer, т. е. передача репрезентативного состояния. REST определяет набор функций, таких как GET, PUT, DELETE и т. д., которые клиенты могут 
использовать для доступа к данным сервера. Клиенты и серверы обмениваются данными по протоколу HTTP.
1. **Клиент-серверная архитектура** Отправитель и получатель независимы друг от друга в отношении технологии, платформы, языка программирования и т. д.
2. **Многоуровневость** На сервере может быть несколько скрытых от клиентов посредников, которые совместно выполняют их запросы.
3. **Единый интерфейс** API возвращает данные в стандартном формате, который является полным и полностью пригодным для использования.
4. **Отсутствие состояний** API выполняет каждый новый запрос независимо от предыдущих.
5. **Кэшируемость** Все ответы API можно кэшировать.
6. **Код по запросу** При необходимости ответ API может включать фрагмент кода
<h2 id="rest_soap-XML>XML</h2>
Расширяемый язык разметки (XML) – это язык разметки, который предоставляет правила для определения любых данных. 
Служит для хранения и передачи данных и метаданных о данных. Теги можно создавать свои, в отличии от (HTML).
<h2 id="rest_soap-JSON>JSON</h2>
JSON-объект — это неупорядоченное множество пар «ключ:значение». Ключ — это название параметра, который мы передаем серверу. 
Значение - описание этого параметра (свойства). Для пары {“ключ”: значение} для «ключа» всегда используют тип string, 
для «значения» применимы типы: string, number, object (тип JSON), array, boolean (true или false) и null

|       Параметр       |                                SOAP                                |                                        REST                                        |    
|:--------------------:|:------------------------------------------------------------------:|:----------------------------------------------------------------------------------:|
|       Гибкость       |               Обмен сообщениями только в формате XML               |          Можно передавать данные в виде обычного текста, HTML, XML и JSON          |
|  Производительность  |                    Сообщения крупнее и сложнее                     |                              Размер соообщений меньше                              |
|   Масштабируемость   |    Не очень. Требования к сохранению состояния между запросами     |       Норм. Поддерживает многоуровневую архитектуру без сохранения состояния       |
|     Безопасность     |   Требует дополнительного уровня WS-Security для работы с HTTPS    |                   Поддерживает HTTPS без дополнительных условий                    |
|      Надежность      | Встроена логика обработки ошибок, обеспечивает большую надежность  |  Требует осуществления повторной попытки в случае сбоев связи, и он менее надежен  |

---

<h1 id="chema">Контейнеры данных XML/JSON, XSD/JSON Schema</h1>

[1](https://habr.com/ru/articles/495766/)
&nbsp;
[2](https://docs.ensi.tech/analyst-guides/tools/json)
&nbsp;

Schema нужна для структуризации сообщений с целью снижения затрат на сопровождения и поддержку системы. Представляют собой
перечень условий грамотно оформленных сообщений.

---

<h1 id="Реляционные-СУБД">Реляционные СУБД</h1>

[tproger](https://tproger.ru/translations/sql-nosql-database-models)
&nbsp;
[1:1](https://habr.com/ru/articles/488054/)
&nbsp;

СУБД — это приложения (или библиотеки), управляющие базами данных различных форм, размеров и типов.

Реляционная модель предлагает математический способ структуризации, хранения и использования данных.
Отношения (англ. relations) дают возможность группировки данных как связанных наборов, представленных в виде таблиц, 
содержащих упорядоченную информацию и соотносящих значения и атрибуты.

<h2 id="Масштабируемость>Масштабируемость</h2>
**Вертикальное масштабирование** — увеличение производительности каждого компонента системы с целью повышения общей производительности. 
Масштабируемость в этом контексте означает возможность заменять в существующей вычислительной системе компоненты более мощными 
и быстрыми по мере роста требований и развития технологий. Это самый простой способ масштабирования, так как не требует никаких изменений в прикладных программах, работающих на таких системах.    
**Горизонтальное масштабирование** — разбиение системы на более мелкие структурные компоненты и разнесение их по отдельным 
физическим машинам (или их группам), и (или) увеличение количества серверов, параллельно выполняющих одну и ту же функцию. 
Масштабируемость в этом контексте означает возможность добавлять к системе новые узлы, серверы для увеличения общей производительности. 
Этот способ масштабирования может требовать внесения изменений в программы, чтобы программы могли в полной мере пользоваться возросшим количеством ресурсов.

<h2 id="Связи>Связи между таблицами базы данных</h2>
* <u>Многие ко многим</u>: каждому элементу первой таблицы соответствует один или несколько элементов из второй, аналогично
по отношению ко второй. Первая таблица указывает на то, к каким группам относится элемент, а вторая - состав каждой группы.
Для реализации нужен некий посредник между двумя рассматриваемыми таблицами. Он должен хранить два внешних ключа, первый из которых ссылается на первую таблицу, а второй — на вторую.
* <u>Один ко многим</u>: элемент первой группы может обладать несколькими элементами второй группы, но элементы второй группы 
однозначно определяются элементом первой группы. Необходим только внешний ключ первой группы.
* <u>Один к одному</u>: уточнение описания элементов изначальной группы. Имеется ограничение, что атрибут может принимать только уникальные значения.

---

<h1 id="Нотации-моделирования">Нотации моделирования</h1>

[UML](https://litresp.ru/chitat/ru/Л/leonenkov-aleksandr/samouchitelj-uml/)
&nbsp;
[UML](https://intuit.ru/studies/professional_skill_improvements/1364/courses/229/lecture/5954?page=4)
&nbsp;
[UML](https://habr.com/ru/articles/458680/)
&nbsp;
[BPMN](https://docs.ensi.tech/analyst-guides/tools/diagrams/bpmn)
&nbsp;
[BPMN](https://habr.com/ru/articles/697326/)
&nbsp;
[BPMN/EPC](https://practicum.yandex.ru/blog/notacii-modelirovaniya-biznes-processov/)
&nbsp;

<h2 id="UML">UML</h2>
UML – унифицированный язык моделирования (Unified Modeling Language) – это система обозначений, которую можно применять 
для объектно-ориентированного анализа и проектирования.

**Диаграмма состояний** позволяет описать поведение отдельно взятого объекта при определенных условиях. Также она покажет 
нам все возможные состояния, в которых может находиться объект, а также процесс смены состояний в результате внешнего влияния.
Состояние (state) - ситуация в жизненном цикле объекта, во время которой он удовлетворяет некоторому условию, выполняет 
определенную деятельность или ожидает какого-то события. Состояние объекта определяется значениями некоторых его атрибутов 
и присутствием или отсутствием связей с другими объектами. Диаграмма состояний показывает, как объект переходит из одного 
состояния в другое. Очевидно, что диаграммы состояний служат для моделирования динамических аспектов системы.   

**Диаграмма классов** _Класс (class) - категория вещей, которые имеют общие атрибуты и операции._ Диаграмма классов - это 
набор статических, декларативных элементов модели. Диаграммы классов могут применяться и при прямом проектировании, 
то есть в процессе разработки новой системы, и при обратном проектировании - описании существующих и используемых систем. 
Именно диаграмма классов дает нам наиболее полное и развернутое представление о структуре и связях в программном коде.

**Диаграмма деятельности** Это технология, позволяющая описывать логику процедур, бизнес-процессы и потоки работ. Во многих случаях они напоминают блок-схемы,
но принципиальная разница между диаграммами деятельности и нотацией блок-схем заключается в том, что первые поддерживают параллельные процессы.
Если говорить кратко, то диаграмма деятельности помогает нам описать логику поведения системы. Диаграммы деятельности 
удобно применять для визуализации алгоритмов, по которым работают операции классов.

**Диаграмма последовательности** относится к диаграммам взаимодействия UML, описывающим поведенческие аспекты системы, но 
рассматривает взаимодействие объектов во времени. Другими словами, диаграмма последовательностей отображает временные 
особенности передачи и приема сообщений объектами. 
**Диаграмма прецедентов** относится к диаграммам взаимодействия UML, описывающим поведенческие аспекты системы, но 
отличается тем, что описывает множество возможных состояний системы (наблюдаемых её составными частями результатами
взаимодействия частей между собой и системой).

<h2 id="BPMN">BPMN</h2>
BPMN (Business Process Model and Notation) - это язык моделирования бизнес-процессов, который является промежуточным 
звеном между формализацией/визуализацией и воплощением бизнес-процесса. Нотация представляет собой описание графических элементов, 
используемых для построения схемы протекания бизнес-процесса. BPMN позволяет описать бизнес-логику выполнения действий в 
виде наглядной диаграммы, а также запустить отрисованный бизнес-процесс на исполнение. Для этого используются специализированные 
системы BPMS (Business Process Management System), поддерживающие эту нотацию.

<h3 id="BPMS">BPMS</h3>
BPMS-системы могут автоматически перевести схему бизнес-процесса в исполняемый код и создать веб-приложение, которое 
будет обрабатывать данные, введённые пользователями и сторонними сервисами. Это соответствует концепции Low Code/No Code 
(создание программного обеспечения без разработки кода) и отлично подходит для автоматизации офисных процессов.
Технически такая возможность реализуется за счёт перевода BPMN-диаграмм в документы формата BPEL (Business Process Execution Language). 
BPEL-документы представляют собой инструкции исполнения бизнес-процессов для веб-сервисов.

<h3 id="уровни-моделирования">Уровни моделирования</h3>
В зависимости от целей построения BPMN-диаграмм, различают 3 уровня моделирования:
1. **_Описательное моделирование_**, когда нужно показать успешный путь выполнения бизнес-процесса, например, чтобы согласовать его с 
бизнес-пользователем. Здесь применяются самые простые элементы нотации, а сама диаграмма намеренно максимально упрощается.
2. **_Аналитическое моделирование_** используется, когда нужно полностью показать все варианты выполнения бизнес-процесса, 
включая логические ветвления и альтернативы. Такая диаграмма обычно создаётся для опытных пользователей и бизнес-аналитиков 
с помощью расширенного алфавита нотации, включая не только её базовые самые простые элементы, но и более сложные.
3. _**Исполняемое моделирование**_ предназначено для запуска на исполнение в BPMS-движке, чтобы создать веб-приложение. 
Здесь может использоваться всё многообразие алфавита этой нотации, включая добавление специальных параметров и 
скриптов, создаваемых разработчиками.

<h3 id="категории-объектов">Категории объектов</h3>
В этой нотации используют шесть основных категорий объектов:
1. **Задачи и действия** Это те активности, которые необходимо исполнить.
2. **События** Это то, что происходит во время процесса. Обозначает уже случившийся факт.    
   * Стартовое — с него начинается любой процесс.
   * Промежуточное — что происходит во время процесса
   * Конечное — финал.
3. **Пул** Это ограниченная прямоугольная область, в которой описывают процесс. 
4. **Дорожки** Разделяют пул и помогают изобразить исполнителей процесса.
5. **Шлюзы** У них есть ещё два названия: логические операторы или точки принятия решений. Это места, в которых процесс 
расходится на несколько потоков или несколько потоков соединяются в один:     
   * Эксклюзивный шлюз — строгое «или», то есть процесс может пойти только по одному пути    
   * Неэксклюзивный шлюз — нестрогое «или», у процессов может быть несколько путей, но не все одновременно.
   * Параллельный шлюз — используется для разветвления или слияния потоков.
6. **Связи** Действия, события, шлюзы соединяются между собой линиями — это связи или потоки операций. Поток по умолчанию 
показывает, в каком направлении двигаться, когда нет новых вводных.

<h2 id="EPC">EPC (процессное моделирование)</h2>
Нотация EPC подходит, когда необходимо детально смоделировать процесс или сделать графическую инструкцию. Часто её 
используют для создания подробных регламентов. Ключевая особенность этой нотации в том, что _**СОБЫТИЯ И
ДЕЙСТВИЯ ВСЕГДА ДОЛЖНЫ ЧЕРЕДОВАТЬСЯ**_. Событие порождает действие, а действие всегда приводит к событию. Таким образом 
можно максимально детально смоделировать бизнес-процесс с обозначением всех промежуточных состояний. 

---

<h1 id="Разработка-документации">Разработка документации</h1>

---

<h1 id="CRUD">CRUD</h1>
  
<img alt="CRUD0" src="SA_init/images/CRUD.png"/>
[1](https://wiki.merionet.ru/articles/chto-takoe-crud)

CRUD – это сокращение от Create (создание), Read (чтение), Update (модификация) и Delete (удаление). Эти четыре функции 
являются ключевыми принципами, которым следуют разработчики и программисты API при создании надежных API. В соответствии с
отраслевым стандартом каждая модель API должна следовать всем этим четырем (или как минимум трем) принципам в процессе выполнения.

1. **Create** Эта функция используется для оповещения о введении любых новых изменений в базу данных и обеспечения их реализации. 
В реляционной базе данных SQL, Create называется INSERT. 
2. **Read** Получение данных. 
3. **Update** Функция модификации полезна для изменения уже существующих записей без внесения каких-либо нарушений в существующую базу данных.
4. **Delete** При помощи этой функции пользователи могут удалять определенные записи или данные из определенной базы данных. 

---

<h1 id="SQL">SQL</h1>

[SQL site](https://www.sql-ex.ru/)
```postgresql
SELECT fio
FROM users
WHERE split_part(rtrim(ltrim(fio)), ' ', 1) LIKE 'ИВАНОВ'
```

<h2 id="SQL:-SELECT">
  <a href="https://metanit.com/sql/postgresql/3.2.php">
    SELECT
  </a>
</h2>
Выбирает строки по идентификаторам (столбцам) из таблицы.

<h2 id="SQL:-WHERE">
  <a href="https://metanit.com/sql/postgresql/3.3.php">
    WHERE
  </a>
</h2>
Если условие после истинно, то строка попадает в результирующую выборку.
* **AND**
* **OR**
* **NOT**
* **IS NULL**
* **IS NOT NULL**

<h2 id="SQL:-DISTINCT">
  <a href="https://metanit.com/sql/postgresql/4.1.php">
    WHERE
  </a>
</h2>
Позволяет выбрать уникальные данные по определенным столбцам.

<h2 id="SQL:-ORDER-BY">
  <a href="https://metanit.com/sql/postgresql/4.2.php">
    ORDER BY
  </a>
</h2>
Позволяет отсортировать значения по определенному столбцу
* **ASC**
* **DESC**

<h2 id="SQL:-LIMIT-OFFSET">
  <a href="https://metanit.com/sql/postgresql/4.3.php">
    LIMIT и OFFSET
  </a>
</h2>
**LIMIT** позволяет извлечь определенное количество строк от начала.   
**OFFSET** позволяет указать, с какой строки надо начинать выборку.

<h2 id="SQL:-IN">
  <a href="https://metanit.com/sql/postgresql/4.4.php">
    IN
  </a>
</h2>
Позволяет определить набор значений, которые должны иметь столбцы.
Выражение в скобках после IN определяет набор значений. Этот набор может вычисляться 
динамически на основании, например, еще одного запроса, либо это могут быть 
константные значения.

<h2 id="SQL:-BETWEEN">
  <a href="https://metanit.com/sql/postgresql/4.4.php">
    BETWEEN
  </a>
</h2>
Определяет диапазон значений с помощью начального **AND** конечного значения, которому должно соответствовать выражение:

<h2 id="SQL:-LIKE">
  <a href="https://metanit.com/sql/postgresql/4.4.php">
    LIKE
  </a>
</h2>
Принимает шаблон строки, которому должно соответствовать выражение.
* **%**: соответствует любой подстроке, которая может иметь любое количество символов, 
при этом подстрока может и не содержать ни одного символа
* **_**: соответствует любому одиночному символу

<h2 id="SQL:-Агрегатные-функции">
  <a href="https://metanit.com/sql/postgresql/4.5.php">
    Агрегатные функции
  </a>
</h2>
Агрегатные функции вычисляют одно значение над некоторым набором строк.
* **AVG**: находит среднее значение;
* **COUNT**: находит количество строк в запросе;
* **SUM**: находит сумму значений;
* **MIN**: находит наименьшее значение;
* **MAX**: находит наибольшее значение;
* **STRING_AGG()**: Функция STRING_AGG() объединяет набор строковых значений или значений bytea.

<h2 id="SQL:-GROUP-BY">
  <a href="https://metanit.com/sql/postgresql/4.6.php">
    GROUP BY
  </a>
</h2>
Оператор **GROUP BY** определяет, как строки будут группироваться. Любой столбец, который используется
в выражении **SELECT** (без учёта столбцов, которые хранят результат агрегатных функций), 
должен быть указан после оператора **GROUP BY**.

<h2 id="SQL:-HAVING">
  <a href="https://metanit.com/sql/postgresql/4.6.php">
    HAVING 
  </a>
</h2>
Оператор **HAVING** указывает, какие группы будут включены в выходной результат, 
то есть выполняет фильтрацию групп. 
Если при этом необходимо провести сортировку, то 
выражение **ORDER BY** идет после выражения HAVING.

<h2 id="SQL:-INNER-JOIN">
  <a href="https://metanit.com/sql/postgresql/6.2.php">
    INNER JOIN 
  </a>
</h2>
Перед **JOIN** можно указывать **необязательный** оператор **INNER**. 
**JOIN** без уточнений всегда ***ВНУТРЕННИЙ***.

<h2 id="SQL:-OUTER-JOIN">
  <a href="https://metanit.com/sql/postgresql/6.3.php">
    OUTER JOIN 
  </a>
</h2>
**OUTER JOIN** позволяет возвратить все строки
одной или двух таблиц, которые участвуют в соединении.
* **LEFT**: выборка будет содержать все строки из первой или левой таблицы;
* **RIGHT**: выборка будет содержать все строки из второй или правой таблицы;
* **FULL**: выборка будет содержать все строки из обеих таблиц.

<h2 id="SQL:-UNION">
  <a href="https://metanit.com/sql/postgresql/6.5.php">
    UNION [ALL]
  </a>
</h2>
Оператор **UNION** позволяет объединить два множества (условно две таблицы). Но в отличие 
от **INNER/OUTER JOIN** объединения соединяют не столбцы разных таблиц, 
а два однотипных набора в один. Если оба объединяемых набора содержат в строках идентичные значения, то 
при объединении повторяющиеся строки удаляются. Если же необходимо при объединении сохранить все, 
в том числе повторяющиеся строки, то для этого необходимо использовать оператор ALL. Если же в 
одной выборке больше столбцов, чем в другой, то они не смогут быть объединены. 

---

<h1 id="Общие-вопросы">Общие вопросы</h1>
- [ ] Какую работу вы ищете?
- [ ] Что вы хотите получить от новой работы?
- [ ] Какими достижениями в своей работе вы гордитесь?
- [ ] Как вы относитесь к переработкам?

<h2 id="Требования">Требования</h2>
- [X] Какие группы требований вы знаете?
  - [X] [1](https://docs.ensi.tech/analyst-guides/tools/classification) 
    - Бизнес требования (БТ) Описывают, как должна работать система или программный продукт, и какими свойствами или характеристиками она должна обладать.
    - Функциональные требования (ФТ) Описывают непосредственно функционал, который необходимо реализовать в продукте или 
    системе. Используются различные UML диаграммы и BPMN для описания бизнес-процессов.
    - Нефункциональные требования (НФТ) Описывают, как должна работать система или программный продукт, и какими свойствами
    или характеристиками она должна обладать.
- [X] Что входит в нефункциональные требования?
  - Требования к документированию 
  - Требования к дизайну, usability
  - Атрибуты качества:
    - производительность (возможное количество одновременных операций в системе);
    - эффективность (использование доступных вычислительных мощностей);
    - надёжность (вероятность отказа системы);
    - доступность (режим работы системы без простоев);
    - информационная безопасность (исключение доступности данных системы неавторизованным лицам);
    - масштабируемость (способность системы адаптироваться к увеличению нагрузки);
    - требования к времени хранения данных;
  - Ограничения (юридические, бизнес правила, архитектурные и т.п.).
  - 
<h2 id="UML-и-BPMN">Нотации UML и BPMN</h2>
- [X] Какими нотациями вы владеете?
  - Ни одной
- [X] Что такое диаграмма последовательности? (Что описывает диаграмма последовательности?)
  - [X] Последовательные во времени состояния компонентов и результаты их взаимодействия (сообщения)
- [ ] Нарисуйте диаграмму последовательности для процесса, когда пользователь через веб-форму отправляет запросы в rest-сервис для получения данных.

<h2 id="SQL-FAQ">SQL</h2>
[1](https://habr.com/ru/articles/790850/)
&nbsp;
[2](https://qarocks.ru/sql-interview-part-2/)
&nbsp;

- [X] Зачем нужны индексы в таблицах БД?
  - [X] Индекс в SQL — это структура данных, которая создается для одного или нескольких столбцов таблицы с целью повышения производительности запросов. Индексы работают путем создания отдельной структуры данных, которая содержит копии индексируемых столбцов в отсортированном порядке. 
- [X] Знакомы ли вы с нормализацией баз данных?
  - [X] Нормализация – это процесс организации данных в базе таким образом, чтобы уменьшить их избыточность и обеспечить целостность. Она включает в себя разбиение базы данных на более мелкие, более управляемые таблицы и установление связей между ними.
- [X] Какие виды JOIN запросов вы знаете? Чем LEFT JOIN отличается от FULL JOIN ?
  - [X] INNER, LEFT, RIGHT, FULL;
- [X] Чем TRANCATE отличается от DELETE?
  - [X] Первый стирает все строки без возможности отмены операции, второй работает избирательно и возможен откат изменений;
- [x] Чем отличается UNION от UNION ALL?
  - [X] Первый не оставляет повторяющиеся строки в отличие от второго;
- [X] Для чего используется HAVING в SQL?
  - [X] Для фильтрации групп после оператора **GROUP BY** или агрегирования.

<h2 id="Интеграция">Интеграция</h2>
- [X] Чем SOAP отличается от REST?
  - [X] SOAP - это протокол для создания точки связи клиент-сервер подобных систем, а REST определяет правила 
  организации клиент-сервер подобных систем. Различные возможности работы с данными и масштабирования, безопасности.

<h2 id="Методологии-разработки-ПО">Методологии разработки ПО</h2>
- [ ] Чем Kanban отличается от Scrum?
- 
<h2 id="Прочие-вопросы">Прочие вопросы</h2>
- [X] Чем авторизация отличается от аутентификации?
  - [X] [1](https://thecode.media/autorize/) **Аутентификация** — это когда нужно подтвердить, что мы это именно мы, а не кто-то другой.
  **Авторизация** — это когда система смотрит на результат аутентификации и решает, что этому пользователю можно делать, а что нельзя
- [ ] Чем бизнес-аналитик отличается от системного аналитика?
- [ ] Что такое уровень абстракции?
- [X] Что можете рассказать про хеширование?
  - Генерация уникального идентификатора входной строки без возможности восстановления первоначального вида строки.
  Применяется в сфере безопасности, обработки данных.

---

